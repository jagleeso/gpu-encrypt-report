OB2D: Opportunistic Backup Block Device for Mobile Devices
Beom Heyn Kim Eunbyung Park
Department of Computer Science
University of Toronto
2013 Apr 15

___ OUR INTRODUCTION ___

1 Introduction

Smartphone is getting more and more important as a personal data storage because it is becoming increasingly popular as a portable personal computing device. According to Gartner’s report in 2011, the number of mobile devices sold exceeds that of PCs [ 1 ]. On the other hand, its small form factor which originally attracted many users ironically increases the possibility of losing the devices due to careless mistake or theft. Losing a device means that users will also lose their valuable personal data along with it. Moreover, every personal setting and installed application are gone with the device. According to the infographic prepared by G Cloud Backup, 1 in 4 Americans lose or damage their phone each year and average number of applications people use to backup their smartphones is 6.  Relying on high availability guarantee provided by the Cloud, users are normally trying to use either general personal cloud storage service or application specific synchronization solutions that is based on the cloud.  For example, famous Cloud services such as Dropbox or SugarSync are used to backup their data. iCloud provides synchronization feature not only for user data but also for application settings. G Cloud Backup claims they can solve smartphone backup problem with one solution instead of 6. However, these existing solutions still have not considered several related issues, and there is no suitable generic solution currently. Existing approaches relying on the cloud usually do not take an opportunistic approach to transfer data. Instead, they make extensive used of expensive networks such as 3G or LTE and therefore consume more energy than actually it needs.  Furthermore, for privacy or security sensitive data, users hesitate to put their data on the third-party servers which most of existing solutions are designed around.  In this technical report, we propose to do opportunistic backup using users desktops over the wifi connection.  This can achieve energy saving and can reduce network bandwidth consumption for expensive networks. Moreover, it can help for users to have more control over their data and users do not need to rely on the thirdparty server for storing their data. In order to achieve this goal, we designed and implemented OB2D prototype along with a secure and durable personal cloud storage prototype, Unity [ 5 ].  As a background, Unity is the personal cloud storage that provides security and durability on user’s devices only and still allows to use untrusted cloud server while using cryptographic and distributed systems techniques to ensure untrusted cloud server can not temper with confidentiality, integrity and durability of user data.  Also, it allows any of user devices to become a writer and still can provide consistent disk image by consolidating distributed up-to-date blocks into a single logical canonical disk image any device can access without violating strong consistency model. Specifically, it provides linearizability which is stronger consistency model than widely used weak consistency model or causal consistency model. This strong consistency model was a viable option due to its unique target environment which is for a single user maintaining few devices only as opposed to global-scale or enterprise scale shared distributed file systems.  On top of this Unity devices, we designed OB2D to trickle any changes made to the phone’s storage image to user’s devices nearby over the available WIFI connection. Our observation was that users normally commute between home and office carrying their mobile devices with them. We envision in the near future the mobile device will be the first class personal computing devices and stationary devices will become a supplementary but powerful server to run overwhelming applications or to save battery power. With this, we envision that the mobile devices will become a popular computing platform that various OSes and applications will run on. Thus, we should be able to backup the entire persistent storage image. Also, we should be able to keep track of dirty blocks as well as mode switch facility which will be triggered by the detection of WIFI signal.  We will discuss further detail of implementation of Unity and OB2D work we had completed for the project in the section 2 . Then, our evaluation result is discussed




in the section 3 . Related works are discussed in the section 4 , and future work is listed in the section 5 . Finally, we conclude the report in the section 6 .  2 Implementation 2.1 Developing Unity Primary Switch.  We wanted to make OB2D to write modified data to the backup storage at any of distributed stationary machines. Also, these partial changes made at different locations should collectively aggregate them into a single consistent backup image of the entire mobile phones persistent storage. Unity is perfect for achieving this illusion by providing Linearizability guarantee where only one node can grab the lease to access the distributed persistent storage at any given time. The lease is analogous to the lock which provides mutual exclusion into the storage, and the lease-holder is called Primary.  Before OB2D can write to the storage on the stationary device, the Unity client running on the stationary device should obtain the lease from the old Primary and become the new Primary. Firstly, the new Primary request the lease to the directory server and the directory server forward this request to the old Primary. Once the old Primary gets the request, it respond to the directory server so that the server let the new Primary know it is allowed to receive the Lease from the old Primary. Then, the new Primary waits for the old Primary to become nonPrimary and send the lease. After lease arrived, the new Primary now officially becomes the Primary and notify the directory server.  This entire process is called Primary Switch. The challenge for enabling Primary Switch was making these request handling asynchronously. On the new Primary, there is a separate thread requesting the lease. Also, the server handles request and response forwarding asynchronously. So, both node and server can handle other request while handling the Primary Switch without any deadlock.  Untrusted Cloud Node Support.  Unity does not trust the cloud, but relying on user devices can limit the availability due to frequent leave and departure of users devices – many of them are sleeping or shutdown to conserve power. Thus, instead of completely abandoning the cloud, Unity chooses to use the cloud for the better availability but not for reliability or durability of data.  Because Unity does not trust the cloud, data block replicated by the cloud can unintentionally reveal the privacy of the user. So, Unity encrypts every block going to the cloud with AES-256 symmetric-key block cipher where keys are only stored on users devices. Encryption cannot provide the security of data fully by itself, because the malicious cloud can intentionally corrupt the integrity of Android X86 VM NBD Client NBD Server Syncer Disk I/O requests Host Unity Personal Cloud 3G/WIFI Figure 1: The OB2D prototype architecture data and send it to users devices to corrupt users data eventually. To protect the integrity of the data, Unity employes another cryptographic technique, HMAC, and the key used for HMAC is also shared only by users devices.  The cloud node also runs the metadata server called directory server which basically keeps track of location information for blocks dispersed across users devices and the cloud server. In order to protect the integrity of metadata, each unit of metadata so-called dstate is signed by 2048-bit RSA signing algorithm. Moreover, in order to prevent dropping of dstate by the malicious cloud, a unique sequence number is included in each dstate. Now, to make the full use of cloud server for saving upload bandwidth consumption by users devices, we configured each peers replication strategy so that all nodes can make extensive use of cloud server. With this, peers replicate blocks from the cloud server most of time. To overcome the servers being unavailable due to any failure on serverside or a malicious server activity, users devices also can get the blocks from other peer user devices. Also, the untrusted cloud cannot reduce durability by making data blocks on the cloud unavailable, because user devices also keep block replicas and group them to maintain a consistent snapshot.  2.2 Developing OB2D Client Porting Android to x86 VM.  To measure real applications, we use android platform, which has many popular applications now. For the first stage, we take advantage of x86 android system and virtualized environment to easily test and run real scenarios. Originally x86 android system was developed for several reasons, such as a development tool and application compatibility. Our goal is to run real application and investigate the behaviour of them in terms of access patterns of disk. Thus, leveraging x86 android system would allow us to avoid wasting amount time to use real device and collecting data from it. Fortunately, There already exists several variants of android platform supporting x86 architecture


__ OUR EVALUATION __


One of the important problem was to use of ethernet networking since android systems have been designed for mobile network(3G, LTE) or wireless networking.  In order to take advantage of useful facilities, such as app market(Google Play), network connection is essential part. Even though we could manually download and install applications, some of applications couldnt be executed without network connection. Fortunately we could find patches that force android to use ethernet networking and succeed to run almost all of applications from app market except for applications leveraging 3D graphic acceleration.  We use the virtualbox hypervisor for running x86 android since it is easy to use, appropriate to run x86 android platform, and very well documented. At the first time, we considered Xen or KVM hypervisor, but it turns out that they have very poor performance in terms of response time and interactivity of GUI system.  Finally, we had to collect all of disk accesses from android platform, to do so, we decided to use raw disk format. It enable us to intercept all of the disk accesses in the view of host operating system with the help of some useful tools, such as nbd or kernel driver. We could instead insert those tools directly inside x86 android virtual machine. However, it would require much effort to port those tools to android platform and there would not give us any advantages compared to our approach, in terms of collecting disk access patterns.  Syncer process OB2D is designed to work in two different operation mode such as hoarding mode and syncing mode . When there is no WIFI signal around, the device will hoard whatever changes made to its persistent storage by marking on the dirty bitmap. The mode switch to the sycing mode will be triggered when the device sensor detect the WIFI signal. In the syncing mode, OB2D starts trickling changes by scanning the dirty bitmap and transferring the block content over the network. On the other side of the network, the daemon process running on the Unity device will write block contents to the block device exported by the Unity’s kernel component. Then, Unity will make sure replication for durability is completed and handle the data in a way that users can be assured of its security as well. As we mentioned earlier, we take the advantage of x86 android virtual machine for simplicity. Furthermore, we decided to use network block device(NBD) for intercepting and investigating the all possible disk I/O requests from the virtual machine.  The NBD client intercepts disk I/O requests and traps into the NBD server process. Then NBD server process maintains the dirty bitmap while we are in the HOARD mode. The syncer thread is in charge of synchronizing data between host machine and backup cloud server. We assume that there are some ways to detect wifi connection available so that we can inject this wifi-connectionName Description Booting Booting process Facebook Read up-to-date around 20 news feeds(text, pictures) Bank View account information Browser Web surfing for 10 minutes Game Playing game for 10 minutes Install Installation of application from app-market Map Navigating by using maps Email Read e-mails Office Google docs(word, powerpoint) Table 1: Benchmark applications detection event to the NBD server, which gives rise to spawn syncer thread to sync dirty data to the cloud.  2.3 Optimizations We could apply two optimization techniques to reduce the size of data transferred, which leads to improve energy efficiency. The first thing is called deduplication, which exploits the fact that a block doesnt need to be transferred every time if the block are frequently being written at certain times. For example, lets assume that we would backup every five minutes and some blocks are being updated a lot in five minutes. All we need to do is to transfer the last update instead of all the updates to the block. Even though the policy about the backup interval is another question, we could simply define the interval as a duration of each benchmark to be completed in order to figure out how much opportunities for this optimization technique the applications will have.  Another technique is delta compression, which is successfully used in the area of virtual machine migration [ 7 ]. The basic idea is to only transfer changes to blocks instead of the full block contents, which leads to reduce the size of the data. The changes usually would seem to be consecutive bits in blocks, which implicitly means that there would be a lot of possibilities to compress the changes from the view of the information theory. First, the block contents who are being written from the applications or android platform will be XORed with original blocks in bit granularity. We then compress the delta bit stream and transfer it to the cloud backup storage.  3 Evaluation We have conducted several real applications over our OB2D prototype for evaluation. We could download all of applications from the Google Play, which is an application market in the android platform. For each applications, a typical way of using these applications have been suggested, which is described in the Table 1 . The Booting represents the all of block I/O requests during the booting process. We have read around 20 up-to



Figure 2: The results of data transfer date news feeds including text and pictures in the case of the Facebook. For Bank applications, we have viewed our own bank account once. We have been using web browser and playing game for 10 minutes as the name suggested. For Install, we have installed the application from app market. We have used the Map applications for navigating our way to work. Finally, we have read emails from Email apps and have performed simple documentation tasks with Google docs.  Data transfer.  We could imagine that the boot, map, and install would have many block I/O requests. However, the results have shown that there would be counterintuitively a lot of block I/O requests in other applications, such as the facebook and web browser. It turns out that these kind of applications aggressively use temporary files to cache the data to improve responsiveness, including photo, text, and even metadata. For deduplication, many of applications did not have much gain except for web browser that we could reduce almost half of data to transfer. In addition, we guess that its usefulness would be maximized when we set long backup intervals.  For delta compression, it turns out that this optimization techniques is very useful for most of applications we performed. It proved our guess that most of updates to blocks were consecutive bits and small changes. In addition, these two techniques are orthogonal each other, so we could combine two techniques and expect to show better results that the result that we applied only one optimization.  Power consumption.  Our ultimate goal is to improve energy efficiency, so we should be able to measure power consumption. Since we couldnt use real mobile device and real power meter, we had to approximate the energy consumption with the data we generated from our prototype architecture. The recent study suggested that simple data transfer power model can approximate the power consumption with data throughput and some constant parameters [ 4 ]. It comprehensively studied over recent 4G LTE networks and compared to 3G and WiFi networks. The power model only depends on the data 0 100 200 300 400 500 600 700 800 900 WIFI LTE 3G (J) Figure 3: The results of power consumption transfer rate, we thus could simply calculate energy consumption with our data. As we expected, WiFi gives us the best energy efficiency. LTE would also give us better energy efficiency in normal case, however, in the case of low data throughput, 3G would give us low energy consumption because of the parameter beta. In other words, LTE would consume more energy to initialize and finalize the network connection, but 3G consume more energy to continuously transfer data.  With the intuition over power model, we could easily interpret the energy consumption of our data. Energy consumption with WiFi connection shows lowest level in proportional to the size of data transferred as we expected. In the cases of Booting, Install and Map1, LTE consumed more energy than 3G since these workload had a very short duration of data transfer, which means that the constant parameter beta from power model dominates the final energy consumption. For rest of the applications 3G consumed more energy than LTE, but the differences were not big except for the Game application.  This is because the Game was performed relatively for a long time, which is good for LTE networks. Even though there is a variation between LTE and 3G, we can simply assume that WiFi will give us the best results and 3G and LTE will give almost same bad results in terms of energy consumption. In sum, this results would give us a basis for making backup policy.  Concrete example.  In order to figure out usefulness of our work in real world, we simply combined our benchmark applications to make real scenarios of smartphone usages. We have traced 4 hour use of smartphone and plotted as a cumulative data transferred. One of the interesting thing is that something happen when they are in idle state, which results in ascending curve in the result. It seems to be a periodic works in the android platform. Total data transfer was about 250MB and energy consumption was 700 3000J by our proposed power model. The gap between WiFi and others are about 2300J, which is almost 10 percent of battery capacity in recent Nexus 4 smartphone. We would say tha





50 100 150 200 250 300 (MB) Facebook E mail Web browser I dle Install game Playing game Bank I dle Playing game Office Map Total Data Transfer: 242MB Energy Consumption: WIFI 700J LTE 3164J 3G 2937J **Nexus 4 Bettery : 28728J 4 hours Figure 4: The example of real scenario once we could backup only over WiFi networks we can achieve significant energy saving to backup full smartphone system.  




__ OUR RELATED WORK __



4 Related Work Cloudlet [ 6 ] proposes using public infrastructure nearby mobile devices to avoid using WAN and not to be constrained by the limited resource of devices. However, it is different from OB2D because the work does not consider using personal devices for security and privacy. KeyPad and CleanOS [ 2 , 8 ] are work that trying to secure data on the mobile devices that are lost or stolen by using encryption technique as well as cleaning up the plaintext data regularly. However, none of these works actually address issue of recovering data or making power-efficient backup.  
4 Related Work Cloudlet [ 6 ] proposes using public infrastructure nearby mobile devices to avoid using WAN and not to be constrained by the limited resource of devices. However, it is different from OB2D because the work does not consider using personal devices for security and privacy. KeyPad and CleanOS [ 2 , 8 ] are work that trying to secure data on the mobile devices that are lost or stolen by using encryption technique as well as cleaning up the plaintext data regularly. However, none of these works actually address issue of recovering data or making power-efficient backup.  
4 Related Work Cloudlet [ 6 ] proposes using public infrastructure nearby mobile devices to avoid using WAN and not to be constrained by the limited resource of devices. However, it is different from OB2D because the work does not consider using personal devices for security and privacy. KeyPad and CleanOS [ 2 , 8 ] are work that trying to secure data on the mobile devices that are lost or stolen by using encryption technique as well as cleaning up the plaintext data regularly. However, none of these works actually address issue of recovering data or making power-efficient backup.  
4 Related Work Cloudlet [ 6 ] proposes using public infrastructure nearby mobile devices to avoid using WAN and not to be constrained by the limited resource of devices. However, it is different from OB2D because the work does not consider using personal devices for security and privacy. KeyPad and CleanOS [ 2 , 8 ] are work that trying to secure data on the mobile devices that are lost or stolen by using encryption technique as well as cleaning up the plaintext data regularly. However, none of these works actually address issue of recovering data or making power-efficient backup.  


__ OUT FUTURE WORK __


5 Future Work 
Currently, OB2D cannot switch operation modes automatically. Also, it cannot collect real traces from the real device, since it is merely relying on x86 VM running Android. Our first thing to do is to port the OB2D components into the Android OS and run it on the real physical mobile device. Although OB2D is targeting for the whole persistent storage backup while treating the entire phone as black box for compatibility with legacy codes, it can benefit from the support from the OS. For example, there is a large portion of data to be transferred for ephemeral data from web browsing. If OB2D can gain some knowledge on this and can distinguish temporary data from persistent data, it can save bandwidth even further and therefore can save power consumption further.  Moreover, offloading tasks onto the backed up data might be helpful to save more power and can improve performance as well. Hence, integrating with some offloading platform such as COMET [ 3 ] can be another interesting future work.  


__ OUR CONCLUSION __

6 Conclusion In this paper, we designed and implemented OB2D prototype along with Unity personal cloud storage prototype, in order to achieve power efficient full system backup system for smartphone platforms. We have evaluated the system with real applications and shown that several optimization techniques will be very useful. Finally, we also have shown that there will be a significant energy savings to backup.
